/**********************************************************************************************************
*文件说明：滴答定时器配置文件
*实现功能：实现滴答定时和延迟,采用滴答定时器
*修改日期：2018-11-17
*修改作者：crystal cup
*修改备注：
**********************************************************************************************************/
#include "systick.h"
#include "copter.h"


system_loop_time LoopTime ;  //系统循环运行时间结构题定义
volatile float Cycle_T[GET_TIME_NUM][3];
uint32_t SystemCoreClock = 216000000;    //定义系统时钟
static uint32_t fac_us=0;				
static uint32_t fac_ms=0;		
int time_1h,time_1m,time_1s,time_1ms;//实现1h,1minute,1s,1ms,计时开始

	
/***************************************************************************************************************************************
*函数原型: void Systick_Init(uint32_t Systick_Time)
*函数功能: 配置滴答定时器实现中断
*输入参数: Systick_Time：设定这个值可以实现多少中断一次;系统时钟216 000000,滴答定时器时钟27000000,设定Systick_Time=27000,1ms中断一次
*返回数据: none
*修改日期: 2018-11-17
*备注信息：
***************************************************************************************************************************************/

void Systick_Init(uint32_t Systick_Time)
{
	SysTick_Config(Systick_Time);               //配置滴答定时器1ms中断
}


/**********************************************************************************************************
*函数原型: void delay_init(u8 SYSCLK)
*函数功能: 延迟函数初始化,可以配置1us的延迟;SYSCLK=216,
*输入参数: 
*返回数据: none
*修改日期: 2018-11-17
*备注信息：滴答定时器周期是1ms
**********************************************************************************************************/

void delay_init(u8 SYSCLK)
{
	u32 reload;
    HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);//SysTick频率为HCLK
	fac_us=SYSCLK;						    //不论是否使用OS,fac_us都需要使用
	reload=SYSCLK;					        //每秒钟的计数次数 单位为K	   
	reload*=1000000/1000;		//根据delay_ostickspersec设定溢出时间
											//reload为24位寄存器,最大值:16777216,在216M下,约合77.7ms左右	
	fac_ms=1000/1000;			//代表OS可以延时的最少单位	   
	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;//开启SYSTICK中断
	SysTick->LOAD=reload; 					//每1/OS_TICKS_PER_SEC秒中断一次	
	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk; //开启SYSTICK
}		

/**********************************************************************************************************
*函数原型: void delay_us(u32 nus)
*函数功能: 延时nus
*输入参数: nus为要延时的us数.
*返回数据: none
*修改日期: 2018-11-17
*备注信息：注意:nus的值,不要大于798915us(最大值即2^24/fac_us@fac_us=21)
**********************************************************************************************************/
void delay_us(u32 nus)
{		
	u32 ticks;
	u32 told,tnow,tcnt=0;
	u32 reload=SysTick->LOAD;				//LOAD的值	    	 
	ticks=nus*fac_us; 						//需要的节拍数 
	told=SysTick->VAL;        				//刚进入时的计数器值
	while(1)
	{
		tnow=SysTick->VAL;	
		if(tnow!=told)
		{	    
			if(tnow<told)tcnt+=told-tnow;	//这里注意一下SYSTICK是一个递减的计数器就可以了.
			else tcnt+=reload-tnow+told;	    
			told=tnow;
			if(tcnt>=ticks)break;			//时间超过/等于要延迟的时间,则退出.
		}  
	};	

}


/**********************************************************************************************************
*函数原型: void delay_ms(u16 nms)
*函数功能: 延时nms
*输入参数: nus为要延时的us数.
*返回数据: none
*修改日期: 2018-11-17
*备注信息：注意nms的范围,SysTick->LOAD为24位寄存器,所以,最大延时为:nms<=0xffffff*8*1000/SYSCLK
           对216M条件下,nms<=621ms SYSCLK单位为Hz,nms单位为ms
**********************************************************************************************************/

void delay_ms(u16 nms)
{	 		 
	delay_us((u32)(nms*1000));				//普通方式延时	
	    
} 

/**********************************************************************************************************
*函数原型: uint32_t GetSysTime_us(void) 
*函数功能: 获取系统时间
*输入参数: nus为要延时的us数.
*返回数据: none
*修改日期: 2018-11-27
*备注信息：
**********************************************************************************************************/

uint32_t GetSysTime_us(void) 
{
	register uint32_t ms;
	u32 value;
	ms = SysTickUptime;
	value = ms * TICK_US + (SysTick->LOAD - SysTick->VAL) * TICK_US / SysTick->LOAD;
	return value;
}
/*================================================================================================================================*/
/*================================================================================================================================*
**函数原型 : float Get_Cycle_Time(uint8_t item)	
**功    能 : 获取系统运行时间
**输    入 : item
**输    出 : None
**备    注 : 我们这里可以选择配置获取系统的运行时间，
             Get_Cycle_T(0):系统的初始化的时间，
             Get_Cycle_T(1):系统的内环运行时间，
             Get_Cycle_T(2):系统的外环运行时间，
             Get_Cycle_T(3):
**===============================================================================================================================*/
/*==============================================================================================================================*/
float Get_Cycle_Time(uint8_t item)	
{
	Cycle_T[item][OLD] = Cycle_T[item][NOW];	        //上一次的时间,Cycle_T[1][1]=Cycle_T[1][0]
	
	Cycle_T[item][NOW] = GetSysTime_us()/1000000.0f; //本次时间,Cycle_T[1][0]=多少s,这里已经转换成多少s
	
	Cycle_T[item][NEW] = ( ( Cycle_T[item][NOW] - Cycle_T[item][OLD] ) );//间隔的时间（周期）Cycle_T[1][2]，这是运行的周期函数
	return Cycle_T[item][NEW];
}





void Task_Trigger_Start(void)
{
  
	if(time_1ms < 999) //小于1s
	{
    time_1ms++;
    
		Loop_check();
	}
	else    //大于1s
	{
		
    time_1ms =0;
	  if(time_1s<59)  //小于1分钟
	  {
      time_1s++;
		}
		else  //大于1分钟
		{
			time_1s = 0;
			if(time_1m<59)  //小于60分钟
			{
				time_1m++;
			}
			else       //大于60分钟
			{
				time_1m = 0;
				if(time_1h<23)  //小于24h
				{
					time_1h++;
				}
				else          //大于24h
				{
					time_1h = 0;
				}
			}
		}
	}
}

/*====================================================================================================*/
/*====================================================================================================*
**函数原型 : void Loop_check(void)
**功    能 : 循环检测
**输    入 : None
**输    出 : None
**备    注 : 
**====================================================================================================*/
/*====================================================================================================*/
void Loop_check(void)
{
     LoopTime.cnt_1ms++;    //1ms中断
	 LoopTime.cnt_2ms++;   //2ms中断
	 LoopTime.cnt_4ms++;   //2ms中断
     LoopTime.cnt_5ms++;  //5ms中断
	 LoopTime.cnt_10ms++;//10ms中断
	 LoopTime.cnt_20ms++;//20ms中断
	 LoopTime.cnt_25ms++;//25ms中断
	 LoopTime.cnt_50ms++;//50ms中断
	 LoopTime.cnt_80ms++;//80ms中断
	 LoopTime.cnt_90ms++;//90ms中断
	 LoopTime.cnt_100ms++;//50ms中断
    if( LoopTime.check_flag == 1)
	{
		LoopTime.err_flag ++;     //每累加一次，证明代码在预定的时间内没有跑完
	}
	else
	{	
		LoopTime.check_flag = 1;	//该标志位最后被清零
	}
}



/***********************************************************************************************************
*                               NoneQuadrotor UAV file_end
***********************************************************************************************************/
